<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>~ Austin G. Davis-Richardson</title>

  <style type="text/css">
    /* Default styles for all screen sizes */

    html, body {
      margin: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #fff;
      font-family: "Consolas", monospace;
    }

    body {
      padding: 20px;
      width: 800px;
      display: block;
    }

    :not(pre) > code {
      border-radius: 4px;
      padding: 1px;
      background-color: #eee;
      font-style: italic;
      font-family: "Consolas", monospace;
    }

    .blog-description li {
      margin-bottom: 30px;
    }

    .no-dots li {
      list-style: none;
    }

    :root {
        --link-color: black;
    }

    a {
        color: var(--link-color);
        font-weight: bold;
    }

    hr {
      color: #fff;
      background-color: var(--link-color);
    }

    pre {
      padding: 12px;
      border-radius: 6px;
      font-family: "Consolas", monospace;
      white-space: pre-wrap; /* Allow text to wrap on small screens */
    }

    .dimmed {
      color: #777;
    }

    /* Media query for smaller screens (e.g., mobile phones) */
    @media (max-width: 768px) {
      body {
        padding: 10px; /* Adjust padding as needed for smaller screens */
      }

      pre {
        padding: 8px; /* Adjust padding as needed for smaller screens */
      }
    }
  </style>
</head>

<body>


  <div id="header">
    <h1>
      <canvas id="the-canvas" width=50 height=50>
      </canvas>
      <span id="title">agdr.org</span>
    </h1>
  </div>
  <hr/>

  <div>
    

<a href="/">&lt; Back</a>

<h1 class="title">
  Compressive Sensing
</h1>

<p class="subtitle dimmed">2011-05-23</p>


<h2 id="comparing-dna-sequences-using-gzip">Comparing DNA sequences using <code>gzip</code></h2>
<p>I read something somewhere that described a simple data mining technique that
used compression to determine if two strings are similar to each other. I can't
find that article now but I always wanted to try it. The method works by
comparing the size of the compressed versions of the strings to the size of the
strings if they are compressed together. If the strings are similar, the
compressed size will be smaller than the sum of the compressed sizes for the
individual strings. If not, it will be greater.</p>
<p>For example, if you want to compare two strings to see if they are similar,
first compress them separately and get the length of the compressed strings:</p>
<pre data-lang="ruby" style="background-color:#2b2c2f;color:#cccece;" class="language-ruby "><code class="language-ruby" data-lang="ruby"><span style="color:#5fb3b3;">&gt;&gt;</span><span> compress</span><span style="color:#5fb3b3;">(&quot;</span><span style="color:#99c794;">Austin</span><span style="color:#5fb3b3;">&quot;)
</span><span style="color:#5fb3b3;">=&gt; </span><span style="color:#f99157;">9
</span><span style="color:#5fb3b3;">&gt;&gt;</span><span> compress</span><span style="color:#5fb3b3;">(&quot;</span><span style="color:#99c794;">Boston</span><span style="color:#5fb3b3;">&quot;)
</span><span style="color:#5fb3b3;">=&gt; </span><span style="color:#f99157;">8
</span></code></pre>
<p>Now compress them together:</p>
<pre data-lang="ruby" style="background-color:#2b2c2f;color:#cccece;" class="language-ruby "><code class="language-ruby" data-lang="ruby"><span style="color:#5fb3b3;">&gt;&gt;</span><span> compress</span><span style="color:#5fb3b3;">(&quot;</span><span style="color:#99c794;">AustinBoston</span><span style="color:#5fb3b3;">&quot;)
</span><span style="color:#5fb3b3;">=&gt; </span><span style="color:#f99157;">12
</span></code></pre>
<p>12 is still more than 9 but less than 17 (the sum of separately compressed
sizes). So the strings must be similar.</p>
<p>I wanted to see if this would work with querying DNA databases for similar
genes, so I wrote a <a href="https://agdr.org/blog/compressive-sensing/#source">little script</a>.</p>
<p>I did some quick testing on a 16S database and by golly it seems to work. Even
with partial sequences. I would like to do some benchmarking to see how
accurate it is.</p>
<p>This isn't really useful for searching a database as it still requires a
one-to-one comparison of every sequence. However, gzip may be faster than
Needleman-Wunsch (I couldn't find the Big O for gzip). So, it could be used to
get a similarity score in cases where you don't need to see an actual
alignment.</p>
<h2 id="source">Source</h2>
<pre data-lang="ruby" style="background-color:#2b2c2f;color:#cccece;" class="language-ruby "><code class="language-ruby" data-lang="ruby"><span>LEVEL </span><span style="color:#5fb3b3;">= </span><span style="color:#f99157;">9
</span><span>
</span><span>database </span><span style="color:#5fb3b3;">= </span><span style="color:#fac863;">ARGV</span><span style="color:#5fb3b3;">[</span><span style="color:#f99157;">0</span><span style="color:#5fb3b3;">]
</span><span>query </span><span style="color:#5fb3b3;">= </span><span style="color:#fac863;">ARGV</span><span style="color:#5fb3b3;">[</span><span style="color:#f99157;">1</span><span style="color:#5fb3b3;">]
</span><span>
</span><span style="color:#6699cc;">require </span><span style="color:#5fb3b3;">&#39;</span><span style="color:#99c794;">zlib</span><span style="color:#5fb3b3;">&#39;
</span><span>
</span><span style="color:#5f6364;"># Compression function.
</span><span style="color:#c594c5;">def </span><span style="color:#6699cc;">deflate</span><span style="color:#5fb3b3;">(</span><span style="color:#f99157;">string</span><span style="color:#5fb3b3;">)
</span><span>   z </span><span style="color:#5fb3b3;">= </span><span style="color:#fac863;">Zlib</span><span style="color:#5fb3b3;">::</span><span style="color:#fac863;">Deflate</span><span style="color:#5fb3b3;">.</span><span style="color:#6699cc;">new</span><span style="color:#5fb3b3;">(</span><span>LEVEL</span><span style="color:#5fb3b3;">)
</span><span>   dst </span><span style="color:#5fb3b3;">=</span><span> z</span><span style="color:#5fb3b3;">.</span><span>deflate</span><span style="color:#5fb3b3;">(</span><span>string</span><span style="color:#5fb3b3;">, </span><span style="color:#fac863;">Zlib</span><span style="color:#5fb3b3;">::</span><span>FINISH</span><span style="color:#5fb3b3;">)
</span><span>   z</span><span style="color:#5fb3b3;">.</span><span>close
</span><span>   dst
</span><span style="color:#c594c5;">end
</span><span>
</span><span style="color:#5f6364;"># Load entire database into memory.
</span><span>db </span><span style="color:#5fb3b3;">= </span><span style="color:#6699cc;">Hash</span><span style="color:#5fb3b3;">.</span><span style="color:#6699cc;">new
</span><span style="color:#fac863;">File</span><span style="color:#5fb3b3;">.</span><span style="color:#6699cc;">new</span><span style="color:#5fb3b3;">(</span><span>database</span><span style="color:#5fb3b3;">).</span><span>read</span><span style="color:#5fb3b3;">.</span><span>split</span><span style="color:#5fb3b3;">(/^&gt;/).</span><span>each </span><span style="color:#c594c5;">do </span><span style="color:#5fb3b3;">|</span><span style="color:#f99157;">record</span><span style="color:#5fb3b3;">|
</span><span>  </span><span style="color:#c594c5;">next if</span><span> record </span><span style="color:#5fb3b3;">== &quot;&quot; </span><span style="color:#5f6364;"># split makes a blank one for some reason
</span><span>  record </span><span style="color:#5fb3b3;">=</span><span> record</span><span style="color:#5fb3b3;">.</span><span>split</span><span style="color:#5fb3b3;">(&quot;\n&quot;)
</span><span>  header</span><span style="color:#5fb3b3;">,</span><span> sequence </span><span style="color:#5fb3b3;">=</span><span> record</span><span style="color:#5fb3b3;">[</span><span style="color:#f99157;">0</span><span style="color:#5fb3b3;">],</span><span> record</span><span style="color:#5fb3b3;">[</span><span style="color:#f99157;">1</span><span style="color:#5fb3b3;">..-</span><span style="color:#f99157;">1</span><span style="color:#5fb3b3;">]
</span><span>  db</span><span style="color:#5fb3b3;">[</span><span>header</span><span style="color:#5fb3b3;">] =</span><span> sequence</span><span style="color:#5fb3b3;">.</span><span>join</span><span style="color:#5fb3b3;">(&#39;&#39;)
</span><span style="color:#c594c5;">end
</span><span>
</span><span style="color:#5f6364;"># Read query sequence, and compress.
</span><span>query_sequence </span><span style="color:#5fb3b3;">=</span><span> \
</span><span>  </span><span style="color:#fac863;">File</span><span style="color:#5fb3b3;">.</span><span style="color:#6699cc;">new</span><span style="color:#5fb3b3;">(</span><span>query</span><span style="color:#5fb3b3;">).</span><span>read</span><span style="color:#5fb3b3;">.</span><span>split</span><span style="color:#5fb3b3;">(/^&gt;/)[</span><span style="color:#f99157;">1</span><span style="color:#5fb3b3;">].</span><span>split</span><span style="color:#5fb3b3;">(&quot;\n&quot;)[</span><span style="color:#f99157;">1</span><span style="color:#5fb3b3;">..-</span><span style="color:#f99157;">1</span><span style="color:#5fb3b3;">].</span><span>join</span><span style="color:#5fb3b3;">(&#39;&#39;) </span><span style="color:#5f6364;"># :D
</span><span>
</span><span>
</span><span style="color:#5f6364;"># Find database sequence is greatest reduction in size
</span><span>
</span><span style="color:#c594c5;">def </span><span style="color:#6699cc;">query</span><span style="color:#5fb3b3;">(</span><span style="color:#f99157;">query</span><span style="color:#5fb3b3;">, </span><span style="color:#f99157;">db</span><span style="color:#5fb3b3;">)
</span><span>  query_size </span><span style="color:#5fb3b3;">=</span><span> deflate</span><span style="color:#5fb3b3;">(</span><span>query</span><span style="color:#5fb3b3;">).</span><span>length
</span><span>  best</span><span style="color:#5fb3b3;">,</span><span> winner </span><span style="color:#5fb3b3;">= </span><span style="color:#f99157;">0</span><span style="color:#5fb3b3;">, &#39;&#39;
</span><span>
</span><span>  db</span><span style="color:#5fb3b3;">.</span><span>each </span><span style="color:#c594c5;">do </span><span style="color:#5fb3b3;">|</span><span style="color:#f99157;">k</span><span style="color:#5fb3b3;">, </span><span style="color:#f99157;">seq</span><span style="color:#5fb3b3;">|
</span><span>    </span><span style="color:#5f6364;"># Compress DB sequence
</span><span>    solo </span><span style="color:#5fb3b3;">=</span><span> deflate</span><span style="color:#5fb3b3;">(</span><span>seq</span><span style="color:#5fb3b3;">).</span><span>length
</span><span>
</span><span>    </span><span style="color:#5f6364;"># Compress both, together
</span><span>    together </span><span style="color:#5fb3b3;">=</span><span> deflate</span><span style="color:#5fb3b3;">(</span><span>seq </span><span style="color:#5fb3b3;">+</span><span> query</span><span style="color:#5fb3b3;">).</span><span>length
</span><span>
</span><span>    </span><span style="color:#5f6364;"># Score
</span><span>    </span><span style="color:#c594c5;">if</span><span> together </span><span style="color:#5fb3b3;">&lt; (</span><span>solo </span><span style="color:#5fb3b3;">+</span><span> query_size</span><span style="color:#5fb3b3;">)
</span><span>      score </span><span style="color:#5fb3b3;">= (</span><span>solo </span><span style="color:#5fb3b3;">+</span><span> query_size </span><span style="color:#5fb3b3;">-</span><span> together</span><span style="color:#5fb3b3;">)/</span><span>seq</span><span style="color:#5fb3b3;">.</span><span>length</span><span style="color:#5fb3b3;">.</span><span style="color:#6699cc;">to_f </span><span style="color:#5f6364;"># Normalize by subject length
</span><span>      </span><span style="color:#c594c5;">if</span><span> score </span><span style="color:#5fb3b3;">&gt;</span><span> best
</span><span>        best </span><span style="color:#5fb3b3;">=</span><span> score
</span><span>        winner </span><span style="color:#5fb3b3;">=</span><span> k
</span><span>      </span><span style="color:#c594c5;">end
</span><span>    </span><span style="color:#c594c5;">end
</span><span>
</span><span>  </span><span style="color:#c594c5;">end
</span><span>  </span><span style="color:#5fb3b3;">{:</span><span style="color:#99c794;">score </span><span style="color:#5fb3b3;">=&gt;</span><span> best</span><span style="color:#5fb3b3;">, :</span><span style="color:#99c794;">hit </span><span style="color:#5fb3b3;">=&gt;</span><span> winner</span><span style="color:#5fb3b3;">}
</span><span style="color:#c594c5;">end
</span><span>
</span><span>result </span><span style="color:#5fb3b3;">=</span><span> query</span><span style="color:#5fb3b3;">(</span><span>query_sequence</span><span style="color:#5fb3b3;">,</span><span> db</span><span style="color:#5fb3b3;">)
</span><span style="color:#6699cc;">puts</span><span> result</span><span style="color:#5fb3b3;">[:</span><span style="color:#99c794;">hit</span><span style="color:#5fb3b3;">]
</span></code></pre>



  </div>

  <div>
    <span class="dimmed">
      <hr/>
      (c) 2011-2023 Austin G. Davis-Richardson
      <br/>
      Content licensed under <a href="https://creativecommons.org/licenses/by/4.0/">Creative Commons By 4.0</a>
    </span>
  </div>

  <script type="text/javascript">
    // JavaScript function to create the email address dynamically
    function generateEmail() {
      var user = "hello";
      var domain = "agdr.org";
      var emailAddress = user + "@" + domain;
      var emailElement = document.getElementById("email-link");
      emailElement.innerHTML = emailAddress;
      emailElement.href = "mailto:" + emailAddress;
    }
    generateEmail();

  </script>

  <script type="text/javascript">
   const canvas = document.getElementById('the-canvas');
   const ctx = canvas.getContext('2d');

   const rows = 10;
   const columns = 10;
   const squareSize = 480 / 100;

   function getRandomColor() {
       const letters = '0123456789ABCDEF';
       let color = '#';
       for (let i = 0; i < 6; i++) {
           color += letters[Math.floor(Math.random() * 16)];
       }
       return color;
   }

   function drawGrid(color) {
     for (let i = 0; i < rows; i++) {
         for (let j = 0; j < columns; j++) {
             ctx.beginPath();
             ctx.fillStyle = color || getRandomColor();
             ctx.fillRect(j * squareSize, i * squareSize, squareSize, squareSize);
             ctx.stroke();
         }
     }
   }

   canvas.addEventListener('click', (event) => {
       const x = event.offsetX;
       const y = event.offsetY;

       const columnIndex = Math.floor(x / squareSize);
       const rowIndex = Math.floor(y / squareSize);

       const colorClicked = ctx.getImageData(x, y, 1, 1).data;
       const colorClickedHex = `#${((1 << 24) + (colorClicked[0] << 16) + (colorClicked[1] << 8) + colorClicked[2]).toString(16).slice(1)}`;

       drawGrid();

       document.documentElement.style.setProperty('--link-color', colorClickedHex);
   });
   drawGrid();
 </script>

</body>
</html>
